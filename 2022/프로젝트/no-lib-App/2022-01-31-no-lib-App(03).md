---
date: '2022-01-31'
title: 'ë¼ì´ë¸ŒëŸ¬ë¦¬, í”„ë ˆì„ì›Œí¬ ì—†ì´ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ ë§Œë“¤ê¸° (3) - Core: Router'
categories: ['Project']
---

# âœ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬, í”„ë ˆì„ì›Œí¬ ì—†ì´ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ ë§Œë“¤ê¸° (3)

## Core: Router

<div>
  <h3 style="font-weight: 700">ëª©ì°¨</h3>
  <a href="#router--main">1. ë©”ì¸</a>&nbsp;&nbsp;
  <a href="#router--functions">2. ë¼ìš°í„° ê´€ë ¨ í•¨ìˆ˜</a>&nbsp;&nbsp;
  <hr/>
</div>

<h3 id="router--main">1. index.ts (Router - ë©”ì¸)</h3>

`./core/Router/index.ts`

**1) imports**

```ts
import CustomError from '../CustomError';
import { ComponentItemType } from '../Component';
import { renderRouterPath } from './functions';
import { Publisher } from '../Store';
export * from './functions';
```

**2) Types**

```ts
export type RouterInfo = {
  [key: string]: ComponentItemType;
};

export interface PathChangeOption {
  func: () => Promise<void> | void;
  pathList: string[];
  isIncludePath: boolean;
}

export interface RouterProps {
  readonly routerInfo: RouterInfo;
  readonly publisherList: Publisher[];
  readonly pathChangeOption?: PathChangeOption;
}
```

- **`RouterInfo`**  
  í˜ì´ì§€ë“¤ì˜ ì •ë³´ë¥¼ ë‹´ì€ ê°ì²´ë¥¼ ìƒì„± ì‹œì— ì‚¬ìš© (ì•„ë˜ `createRouterInfo` í•¨ìˆ˜ ì°¸ê³  / _functions.ts_)
- **`PathChangeOption`**  
  í˜ì´ì§€ ì´ë™ í›„ì— ì‹¤í–‰í•  ì˜µì…˜ë“¤ì„ ì„¤ì • (ì•„ë˜ `setCleanUp` ë©”ì„œë“œ ì°¸ê³  / _index.ts_)
  - `isIncludePath`ê°€ _true_ ë¼ë©´ `pathList`ì— í¬í•¨ëœ path ì¼ ê²½ìš° `func`ë¥¼ ì‹¤í–‰  
    (ë°˜ëŒ€ì¼ ê²½ìš° `pathList`ì— í¬í•¨ë˜ì§€ ì•ŠëŠ” pathì¼ ê²½ìš° ì‹¤í–‰ë¨)
- **`RouterProps`**  
  Routerì—ì„œ ì‚¬ìš©ë˜ëŠ” Props.

**3) Class**

```ts
class Router {
  constructor(readonly $target: Element | null, readonly props: RouterProps) {
    try {
      if ($target === null) throw new CustomError({ msgType: 'NOT_FOUND_TARGET', name: this.constructor.name });
      this.init();
    } catch (e) {
      console.error(e);
    }
  }

  /**
   * ğŸ‘¾ init
   * - setPopStateEvent: ì´ì „ í˜ì´ì§€ & ë‹¤ìŒ í˜ì´ì§€ ì´ë²¤íŠ¸ ì„¤ì •
   */
  private init(): void {
    this.setPopStateEvent();
    this.setCleanUp();
    const href = window.location.href;
    const { publisherList, routerInfo } = this.props;
    const calledComponentName = this.constructor.name;
    renderRouterPath({ href, calledComponentName, routerInfo, publisherList });
  }

  /** í˜ì´ì§€ì˜ ì´ë™ì´ ì´ë¤„ì§ˆ ê²½ìš°, pathChangeOption.func() ì‹¤í–‰ */
  private setCleanUp(): void {
    const { pathChangeOption } = this.props;
    if (!pathChangeOption || !this.$target) return;
    const { func, pathList, isIncludePath } = pathChangeOption;

    const observer = new MutationObserver(async (_) => {
      const pathname = new URL(document.location.href).pathname;
      const flag = isIncludePath ? pathList.includes(pathname) : !pathList.includes(pathname);
      if (flag) await func();
    });
    const config = { childList: true, subtree: true };
    observer.observe(this.$target, config);
  }
  private setPopStateEvent(): void {
    window.addEventListener('popstate', () => this.popStateEventHandler());
  }
  private popStateEventHandler(e?: PopStateEvent): void {
    const href = window.location.href;
    const { publisherList, routerInfo } = this.props;
    const calledComponentName = this.constructor.name;
    renderRouterPath({ href, calledComponentName, routerInfo, publisherList });
  }
}

export default Router;
```

- **`init`**  
  popState ì´ë²¤íŠ¸ë¥¼ ë“±ë¡í•˜ê³  í˜„ì¬ urlì˜ ì •ë³´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ `renderRouterPath`ë¥¼ ì‹¤í–‰í•˜ì—¬ pathì— í•´ë‹¹í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ ë Œë”ë§
- **`setCleanUp`**  
  í˜ì´ì§€ê°€ ì´ë™ ë  ë•Œ ì²˜ë¦¬ ë  í•¨ìˆ˜ë“¤ì„ ì‹¤í–‰

<br/>

<h3 id="router--functions">2. functions.ts (Router - ë¼ìš°í„° ê´€ë ¨ í•¨ìˆ˜)</h3>

`./core/Router/functions.ts`

**1) imports**

```ts
import { TargetType, ComponentItemType } from '../Component';
import { Publisher } from '../Store';
import CustomError from '../CustomError';
import { RouterInfo } from '.';
```

**2) functions**

```ts
interface PathProps {
  publisherList?: Publisher[];
  calledComponentName?: string;
}

interface RenderPathProps extends PathProps {
  href?: string;
  componentInfo?: ComponentItemType;
}

/** âœ¨ renderPath: ì£¼ì–´ì§„ hrefì™€ componentInfoì˜ ì •ë³´ë¥¼ í™œìš©í•˜ì—¬ ë Œë”ë§
 *  - ì•„ë¬´ëŸ° ê°’ì´ ì—†ë‹¤ë©´ ê¸°ë³¸ ê°’ì€ notFound í˜ì´ì§€ë¡œ ì´ë™í•˜ë©° ë Œë”ë§
 *    - hrefê°€ ì—†ë‹¤ë©´ ê¸°ë³¸ê°’ì€ '/notFound'
 *    - componentInfoê°€ ì—†ë‹¤ë©´ Componentì˜ ê¸°ë³¸ê°’ì€ NotFoundPage ì»´í¬ë„ŒíŠ¸
 */
export function renderPath({ componentInfo, href, calledComponentName, publisherList }: RenderPathProps = {}): void {
  try {
    if (!href) href = new URL(window.location.href).origin + '/notFound';
    window.history.pushState({ href }, '', href);

    const $root = document.querySelector('#root');
    const info: ComponentItemType = componentInfo ?? {
      $target: $root,
      Component: NotFoundPage, // ì‚¬ìš© ì‹œ, NotFoundPage ì»´í¬ë„ŒíŠ¸ ì„¤ì •í•˜ê¸°
    };
    if (!info.$target) info.$target = $root;

    let { $target, Component: PageComponent, props } = info;
    if (typeof $target === 'string') $target = document.querySelector($target);
    if (!$target) throw new CustomError({ msgType: 'NOT_FOUND_TARGET', name: calledComponentName ?? 'unknown' });
    $target.innerHTML = '';

    if (publisherList) publisherList.forEach((pub) => pub.clear());
    new PageComponent($target, props);
  } catch (e) {
    console.error(e);
  }
}

interface RenderRouterPathProps extends PathProps {
  href: string;
  routerInfo: RouterInfo;
}

/** âœ¨ renderRouterPath: í˜„ì¬ pathë¥¼ ê¸°ë°˜ìœ¼ë¡œ routerInfoì—ì„œ í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì™€ì„œ ë Œë”ë§ */
export function renderRouterPath({
  routerInfo,
  href,
  calledComponentName,
  publisherList,
}: RenderRouterPathProps): void {
  try {
    if (!routerInfo) throw new CustomError({ msgType: 'NOT_FOUND_ROUTER_INFO', name: calledComponentName });
    const { pathname } = new URL(href);
    const info = routerInfo[pathname] ?? routerInfo['/notFound'];

    const { Component: PageComponent, props } = info;
    let $target = info.$target;

    if (typeof $target === 'string') $target = document.querySelector($target);
    if (!$target) return;
    $target.innerHTML = '';

    if (publisherList) publisherList.forEach((pub) => pub.clear()); // Publisher ì´ˆê¸°í™”
    new PageComponent($target, props);
  } catch (e) {
    console.error(e);
  }
}

interface QueryStringDetail {
  key?: string;
  value?: string;
}

/** âœ¨ createQueryStrings: ì¿¼ë¦¬ìŠ¤íŠ¸ë§ ë¶„ì„í•˜ì—¬ ê°ì²´ë¡œ ë°˜í™˜  */
export const createQueryStrings = (queryString: string): QueryStringDetail[] | null => {
  try {
    const regEx = /(?<key>[\w]+)=(?<value>[\w]+)/g;
    const arrMatchs = Array.from(queryString.matchAll(regEx)) ?? [];
    if (!arrMatchs || !arrMatchs.length) return null;
    return arrMatchs.map((v) => v.groups) as QueryStringDetail[];
  } catch (e) {
    return null;
  }
};
```

- **`renderPath`**  
  ì§ì ‘ì ìœ¼ë¡œ í˜ì´ì§€ ì´ë™ì„ í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©  
  (**Router**ì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•Šê³ , **RouterLink** ì»´í¬ë„ŒíŠ¸ì—ì„œ ê¸°ë³¸ì ìœ¼ë¡œ ì‚¬ìš©)
- **`renderRouterPath`**  
  **Router** ì—ì„œ ì‚¬ìš©, Router ì²« ìƒì„± ì‹œ ë“±ë¡ëœ `routerInfo`ì˜ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‘ë™
