---
date: '2022-02-28'
title: '[Inflearn] 자바스크립트 중고급: 근본 핵심 논리 - 섹션 04. Execution Context'
categories: ['JavaScript']
options: { hide: true }
---

# ✨ [Inflearn] 자바스크립트 중고급: 근본 핵심 논리

## 섹션 04. Execution Context

<div style="margin: 8px 0;">
  <h3 style="font-weight: 700">목차</h3>
  <a href="#01">01. 실행 콘텍스트, 실행 콘텍스트 상태 컴포넌트</a></br>
  <a href="#02">02. 렉시컬 환경 컴포넌트, 렉시컬 환경 컴포넌트 구성/설정, 외부 렉시컬 환경 참조, 변수 환경 컴포넌트</a></br>
  <a href="#03">03. 실행 콘텍스트 실행 과정, [정리 시간]</a></br>
  <hr/>
</div>

<h3 id="01">01. 실행 콘텍스트, 실행 콘텍스트 상태 컴포넌트</h3>

<h4 style="font-weight: 700">실행 콘텍스트</h4>

1. **Execution Context**

   1. 함수가 실행하는 영역, 묶음
   2. 함수 코드를 실행하고 실행 결과를 저장
   3. 스펙상의 사양
   4. 실행 콘텍스트 스펙

2. 참고 코드

   ```jsx
   function music(title) {
     var musicTitle = title;
   }
   music('음악');
   ```

   1. `music(’음악’)`으로 함수를 호출하면.. ⭐️
      1. 엔진은 실행 콘텍스트를 생성하고, 실행 콘텍스트는 안으로 이동함.

3. 실행 콘텍스트 실행 단계
   1. 준비 단계, 초기화 단계, 코드 실행 단계
4. Execution Context 생성 시점
   1. 실행 가능한 코드를 만났을 때
5. 실행 가능한 코드 유형
   1. 함수 코드, 글로벌 코드, eval 코드
6. 코드 유형을 분리한 이유
   1. 실행 콘텍스트에서 처리 방법과 실행 환경이 다르기 때문
   2. **코드 유형**
      1. 함수 코드: 렉시컬 환경
      2. 글로벌 코드: 글로벌 환경
      3. eval 코드: 동적 환경

<h4 style="font-weight: 700">실행 콘텍스트 상태 컴포넌트</h4>

```
실행 콘텍스트(EC): {
	렉시컬 환경 컴포넌트(LEC): {}
	변수 환경 컴포넌트(VEC): {}
	this 바인딩 컴포넌트(TBC): {}
}
```

1. 실행 콘텍스트 상태를 위한 오브젝트
   1. 실행 콘텍스트 안에 생성
2. 상태 컴포넌트 유형
   1. **렉시컬** 환경 컴포넌트(LEC):  
      Lexical Environment Component
   2. **변수** 환경 컴포넌트(VEC):  
      Variable Environment Component
   3. **this** 바인딩 컴포넌트(TBC):  
      This Binding Component

---

<h3 id="02">02. 렉시컬 환경 컴포넌트, 렉시컬 환경 컴포넌트 구성/설정, 외부 렉시컬 환경 참조, 변수 환경 컴포넌트</h3>

<h4 style="font-weight: 700">렉시컬 환경 컴포넌트</h4>

1. **렉시컬 환경 컴포넌트란?**
   1. 함수와 변수의 식별자 해결을 위한 환경 설정
2. 함수 초기화 단계에서 해석한..
   1. 함수와 변수를 `{name: value}` 형태로 저장
   2. 이름으로 함수와 변수를 검색할 수 있게 됨
3. 함수 밖의 함수와 변수 참조 환경 설정
   1. 함수 밖의 함수와 변수를 사용할 수 있게 됨

<h4 style="font-weight: 700">렉시컬 환경 컴포넌트 구성 및 설정 / 외부 렉시컬 환경 참조</h4>

```
실행 콘텍스트(EC): {
	렉시컬 환경 컴포넌트(LEC): {
		환경 레코드(ER): {
			point: 100
		},
		외부 렉시컬 환경 참조(OLER): {
			title: "책",
			getTitle: function(){}
		},
	}
}
```

1. **렉시컬 환경 컴포넌트 구성**
   1. 렉시컬 환경 컴포넌트 생성
      1. `function`, `with`, `try-catch`에서 생성
   2. 컴포넌트 구성
      1. 환경 레코드  
         ER: Environment Record
      2. 외부 렉시컬 환경 참조  
         OLER: Outer Lexical Environment Reference
2. **렉시컬 환경 컴포넌트 설정**
   1. 환경 레코드에 함수 안의 함수와 변수를 기록
   2. 외부 렉시컬 환경 참조에 function 오브젝트의 **\[\[Scope\]\]** 를 설정
   3. 따라서 함수 안과 밖의 함수와 변수를 사용할 수 있게 됨
3. **외부 렉시컬 환경 참조**
   1. 스코프와 실행중인 함수가 Context 형태이므로,
      스코프의 변수와 함수를 별도의 처리 없이 즉시 사용할 수 있음
   2. 실행 콘텍스트에서 함수 안과 밖의 함수, 변수를 사용할 수 있으므로  
      함수와 변수를 찾기 위해, 실행 콘텍스트를 벗어 나지 않아도 됨.

<h4 style="font-weight: 700">변수 환경 컴포넌트</h4>

```
실행 콘텍스트(EC): {
	렉시컬 환경 컴포넌트(LEC): {},
	변수 환경 컴포넌트(VEC): {},
	this 바인딩 컴포넌트(TBC): {}
}
```

1. 실행 콘텍스트 초기화 단계에서 렉시컬 환경 컴포넌트와 같게 설정
   1. 이렇게 하는 이유는?  
      ⇒ 초깃값을 복원할 때 사용하기 위한 것
2. 함수 코드가 실행되면..
   1. 실행 결과를 렉시컬 환경 컴포넌트에 설정
   2. 초깃값이 변하게 되므로 이를 유지하기 위한 것

---

<h3 id="03">03. 실행 콘텍스트 실행 과정, [정리 시간]</h3>

<h4 style="font-weight: 700">실행 콘텍스트 실행 과정</h4>

```jsx
var base = 200;
function getPoint(bonus) {
  var point = 100;
  return point + base + bonus;
}
console.log(getPoint(70));
```

1. **전역 환경**
   1. getPoint 오브젝트의 **[[Scope]]**에 글로벌 오브젝트 설정
   2. 마지막 줄에서 `getPoint()` 함수 호출
      1. 엔진은 실행 콘텍스트를 생성하고, 실행 콘텍스트 안으로 이동
2. **getPoint 오브젝트** (function 오브젝트)

   1. **준비 단계**

      1. 컴포넌트를 생성하여 실행 콘텍스트에 첨부
         - **렉시컬** 환경 컴포넌트
         - **변수** 환경 컴포넌트
         - **this** 바인딩 컴포넌트
      2. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부
         - 환경 레코드에는 함수 안의 함수, 변수를 바인딩
      3. **_여기까지의 모습_**

         ```
         실행 콘텍스트(EC): {
         	렉시컬 환경 컴포넌트(LEC) = {
         		환경 레코드(ER): {}
         	},
         	변수 환경 컴포넌트(VEC): {},
         	this 바인딩 컴포넌트(TBC): {}
         }
         ```

      4. 외부 렉시컬 환경 <u>참조</u>(Outer Lexical Environment Reference)를 생성하여,  
         렉시컬 환경 컴포넌트에 첨부하고 function 오브젝트의 **[[Scope]]**를 설정
         - <u>설정</u> 복사하는 개념이고, 할당하는 개념!
      5. **_여기까지의 모습_**

         ```
         실행 콘텍스트(EC): {
         	렉시컬 환경 컴포넌트(LEC) = {
         		환경 레코드(ER): {},
         		외부 렉시컬 환경 참조(OLER): {
         			base: 200
         		}
         	},
         	변수 환경 컴포넌트(VEC): {},
         	this 바인딩 컴포넌트(TBC): {}
         }
         ```

   2. **초기화 단계**

      1. 호출한 함수의 파라미터 값을..
         - 호출된 함수의 파라미터 이름에 매핑
         - 환경 레코드에 작성
      2. 함수 선언문을 function 오브젝트로 생성
      3. 함수 표현식과 변수에 초기값 설정
      4. 여기까지는 <u>외부에 실행 상태를 제공하지 않음</u>
      5. **_여기까지의 모습_**

         ```
         실행 콘텍스트(EC): {
         	렉시컬 환경 컴포넌트(LEC) = {
         		환경 레코드(ER): {
         			bonus: 70,
         			point: undefined
         		},
         		외부 렉시컬 환경 참조(OLER): {
         			base: 200
         		}
         	},
         	변수 환경 컴포넌트(VEC): {},
         	this 바인딩 컴포넌트(TBC): {}
         }
         ```

   3. **실행 단계**
      1. 함수 안의 코드를 실행
         - `var point = 100;`
      2. 실행 콘텍스트 안에서 관련된 함수와 변수를 사용할 수 있음

<h4 style="font-weight: 700">[정리 시간]</h4>

> **요구사항**: 123이 console에 출력되는 과정을 실행 콘텍스트 관점에서 논리적으로 전개하세요.

```jsx
function book() {
  function get() {
    return point;
  }
  var point = 123;
  return get();
}
console.log(book()); // 123
```

1. **전역 환경**
   1. book 오브젝트의 **[[Scope]]**에 글로벌 오브젝트 설정
      - 현재 전역에는 함수 표현식과 다른 변수가 없음
   2. `book()` 함수 호출
   3. 엔진이 실행 콘텍스트를 생성하고, 실행 콘텍스트 안으로 이동 (book 오브젝트)
2. **book 오브젝트** (function 오브젝트)

   1. **준비 단계**

      1. 컴포넌트를 생성하여 실행 콘텍스트에 첨부 (렉시컬, 변수, this)
      2. “렉시컬 환경 컴포넌트 (LEC)”내에 “환경 레코드 (ER)” 생성
      3. “렉시컬 환경 컴포넌트 (LEC)”내에 “외부 렉시컬 환경 참조 (OLER)”를 생성
      4. **_여기까지의 모습_**

         ```
         실행 콘텍스트(EC): {
         	렉시컬 환경 컴포넌트(LEC) = {
         		환경 레코드(ER): {},
         		외부 렉시컬 환경 참조(OLER): {
         			/* 아무것도 없음 (전역 변수 없음) */
         		}
         	},
         	변수 환경 컴포넌트(VEC): {},
         	this 바인딩 컴포넌트(TBC): {}
         }
         ```

   2. **초기화 단계**

      1. 현재 호출한 함수 (book)에는 파라미터가 없음
      2. 함수 선언문을 만나 get의 이름을 가진 function 오브젝트를 생성
         - get 오브젝트의 **[[Scope]]**에 book 오브젝트 설정  
           (**[[Scope]]**에 get 오브젝트 설정..?)
      3. 변수 point를 undefined로 초기화
      4. **_여기까지의 모습_**

         ```
         실행 콘텍스트(EC): {
         	렉시컬 환경 컴포넌트(LEC) = {
         		환경 레코드(ER): {
         			point: undefined,
         			get: function () { ... }
         		},
         		외부 렉시컬 환경 참조(OLER): {
         			/* 아무것도 없음 (전역 변수 없음) */
         		}
         	},
         	변수 환경 컴포넌트(VEC): {},
         	this 바인딩 컴포넌트(TBC): {}
         }
         ```

   3. **실행 단계**
      1. book 함수 안의 코드 실행
      2. `var point = 123;`
      3. `get()` 함수 호출
      4. 엔진이 실행 콘텍스트를 생성하고, 실행 콘텍스트 안으로 이동 (get 오브젝트)

3. book 함수의 **get 오브젝트 (function 오브젝트)**

   1. **준비 단계**

      1. 컴포넌트를 생성하여 실행 콘텍스트에 첨부 (렉시컬, 변수, this)
      2. “렉시컬 환경 컴포넌트 (LEC)”내에 “환경 레코드 (ER)” 생성
      3. “렉시컬 환경 컴포넌트 (LEC)”내에 “외부 렉시컬 환경 참조 (OLER)”를 생성
      4. **_여기까지의 모습_**

         ```
         실행 콘텍스트(EC): {
         	렉시컬 환경 컴포넌트(LEC) = {
         		환경 레코드(ER): {},
         		외부 렉시컬 환경 참조(OLER): {
         			point: 123, // get의 변수, point
         		}
         	},
         	변수 환경 컴포넌트(VEC): {},
         	this 바인딩 컴포넌트(TBC): {}
         }
         ```

   2. **초기화 단계**
      1. 현재 호출한 함수 (get)에는 파라미터, 변수, 함수 선언문이 없으므로 PASS
   3. **실행 단계**
      1. 함수의 코드를 실행 `return point;`
         - 해당 값이 “환경 레코드”에 없다면 “외부 렉시컬 환경 참조"에서 찾음
      2. 실행 콘텍스트 안에서 관련된 함수와 변수를 사용할 수 있음
      3. “외부 렉시컬 환경 참조”에 있는 point 변수의 값을 가져옴
      4. point의 값을 출력하면서 종료

<h4 style="font-weight: 700"># 정리</h4>

1. 실행 콘텍스트는..
   1. 함수가 호출되면 우선 실행 콘텍스트를 만들고 함수를 실행함
      1. 함수에서 실행할 모든 환경을 실행 콘텍스트에 설정하기 때문.  
         그래서 실행이고 콘텍스트.

---