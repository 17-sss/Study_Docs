# 면접 질문 벼락치기

날짜: 2021년 8월 30일 → 2021년 9월 2일
분류: 질문정리

### 자주 나오는 질문들

1.  **브라우저의 렌더링 과정에 대해서 상세하게 설명해달라**  
    브라우저 주소창에 [www.naver.com](http://www.naver.com/) 치면  
    → 네이버 서버를 찾아간다. →  
    DNS(실제 서버가 어디에있는지 알고 있는 서버)가 연결해줄 곳을 찾음 →  
    (여기서 주소 앞에 https가 붙었다면 https방식으로 통신하겠다.) →  
    서버의 기본설정이 대부분 index.html되어 있어 서버에서 이파일을 클라이언트로 보냄  →  
    브라우저는 텍스트로 이루어진 index.html 파일을 파싱한다. →  
    한줄한줄 읽으면서 DOM트리를 만들어나감. →

    중간에 link태그를 만나 css요청이 발생하면, 요청과 응답과정을 거치고 css를 파싱함 →  
    ~~CSS파싱이 끝나면 중단된 html을 다시읽고 DOM트리를 완성~~ →  
    완성된 DOM트리와 CSSOM트리를 합쳐 Render Tree를 만들고 그린다. →

    자바스크립트는..? →  
    중간에 HTML파서는 Script태그 를 만나게 되면 javascript 코드를 실행하기 위해 파싱을 중단 →  
    제어권한을 자바스크립트 엔진에게 넘기고, 자바스크립트 코드 또는 파일을 로드해서 파싱하고 실행

    1. [Script 태그 속성](https://realmojo.tistory.com/96)들
       - `async`: HTML 렌더링을 멈추지 않고 동시에 js 파일을 다운로드하고  
         다운로드가 끝난 후 자바스크립트를 실행
       - `defer`: HTML 렌더링을 멈추지 않고 동시에 js 파일을 다운로드하고  
         HTML 렌더링이 끝난 후 자바스크립트를 실행
    2. Reflow, Repaint
       - 이 둘은 언제 발생할까? ⇒ 돔이 새로 그려질때마다 생긴다.
       - `Reflow`  
         노드의 크기 또는 위치가 변경되어 현재 레이아웃에 영향을 미쳐서 배치를 다시 해야하는 경우 발생  
         (레이어 배치가 다시 일어나는 것)
       - `Repaint`  
         Reflow가 발생한 뒤나 단순한 스타일 변경 후에 발생  
         (백그라운드 컬러 같은게 바뀔 때 일어나는 것)

    - 추가 참고 링크

      [Browser의 기본 구조 및 동작 과정](https://minemanemo.tistory.com/121)

    - 비슷한 질문
      1. **HTML, CSS, JavaScript가 브라우저에서 어떻게 렌더링 되는지 (리패인팅, 리플로우) [참고 링크](https://jongminfire.dev/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81)**  
         HTML 파싱 후, DOM(Document Object Model) 트리 구축 →  
         CSS 파싱 후, CSSOM(CSS Object Model) 트리 구축 →  
         DOM과 CSSOM을 조합하여 렌더트리 (Render Tree) 구축 [참고] →  
         Layout 단계 (Render Tree 노드들이 가지고 있는 스타일과 속성에 따라서  
         브라우저 화면의 어느 위치에 어느 크기로 출력될지 계산하는 단계) →  
         Paint 단계 (Layout 단계가 완료되면 요소들을 실제 화면에 그리게 됨.  
         요소들의 위치와 크기, 스타일 계산이 완료된 Render Tree를 이용해 실제 픽셀 값을 채워 넣음)

2.  **실행 컨텍스트**  
    자바스크립트의 코드들이 실행되기 위한 환경  
    전역 컨텍스트, 함수 컨텍스트 2가지 존재  
    전역 컨텍스트 하나 생성 후에 함수 호출할 때마다 함수 컨텍스트가 생성  
    컨텍스트 생성시 변수 객체(Variable Environment), 스코프 체인(Lexical Environment),  
    this가 생성된다.

    컨텍스트 생성 후 함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면  
    스코프 체인을 따라 올라가며 찾음

    함수 실행이 마무리되면 해당 컨텍스트는 사라진다.  
    페이지가 종료되면 전역 컨텍스트가 사라짐.

    즉, 자바스크립트의 코드가 실행되기 위해서는 변수객체, 스코프체인,  
    this 정보들을 담고 있는 곳을 실행 컨텍스트라고 부름

3.  **호이스팅**  
    변수를 선언하고 초기화 했을 때 선언부분이 최상단으로 끌어올려지는 현상  
    예를 들어, 코드 상단에서 `console.log(a)`를 찍고 하단에서 `var a = 1;` 이라고 했을 때  
    `console.log(a)`는 _undefined_ 라고 나온다.  
    이런 현상을 호이스팅이라고 한다.  
    함수의 경우 함수 표현식은 호이스팅이 적용되지 않으나 일반 함수 선언문은 함수 호이스팅이 적용된다.

    - var, let, const, function, function\*, class 키워드를 사용해서 선언하는  
      모든 식별자(변수, 함수, 클래스 등)는 호이스팅됨!  
      (let, const, class는 호이스팅이 발생하지 않는 것처럼 보일 뿐)
    - 호이스팅은 스코프를 단위로 동작한다.

4.  **var 와 let, const의 차이점**은 무엇인가 (function scope와 block scope의 개념에서)

    - `var`의 경우 함수의 코드 블록만을 지역 스코프로 인정함 (함수 레벨 스코프)  
      `let`, `const`의 경우 모든 코드 블록을 지역 스코프로 인정함 (블록 레벨 스코프)
    - 추가 정보
      - `var` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨  
        이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것
      - 전역 변수의 단점
        1. 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용
        2. 전역 변수는 생명주기가 길다. 메모리 리소스도 오랜 기간 소비
        3. 스코프 체인 상 종점에 존재 (전역 변수의 검색 속도가 가장 느림)
        4. 네임스페이스 오염

5.  **this**

    1. 일반함수의 this와 화살표 함수의 this는 어떻게 다른가?
       - 자바스크립트의 내부함수는 일반 함수, 메소드, 콜백 함수 어디에서 선언되었든지  
         this는 전역 객체를 가르킴
       - 일반함수의 this는 window(전역)을 가르키며, 화살표 함수의 this는 언제나  
         상위스코프의 this를 가르킴
    2. call, apply, bind에 대해 설명해달라 (3가지 방법은 this를 바인딩하기 위한 방법)
       - `call` this를 바인딩하면서 함수를 호출하는 것,  
         두 번째 인자로는 apply와 다르게 인수목록을 받음  
         (배열을 전개 연산자로 펼쳐서 넣기 가능)
       - `apply` this를 바인딩하면서 함수를 호출하는 것,  
         두 번째 인자로는 call과 다르게 인수배열 하나만 받음
       - `bind` this를 바인딩하면서 함수를 호출하지는 않음  
         this가 바인딩된 새로운 함수를 만들어냄  
         두 번째 인자로는 인수목록을 받음  
         (배열을 전개 연산자로 펼쳐서 넣기 가능)
    3. use strict의 this?
       - 일반함수에서의 this는 undefined가 바인딩 됨.
    4. 함수 호출 방법엔 몇가지가 있을까?
       - 일반함수 호출/ 메서드 호출 / 생성자함수 호출 / 어플라이 콜 바인드 간접호출

6.  **클로저**  
    반환된 내부함수가 자신이 선언되었을 때 환경인 스코프를 기억하여  
    환경 밖에서 호출이 되어도 그 환경에 접근할 수 있는 함수
    **자신이 생성될 때의 환경을 기억하는 함수**.

    1. 사용하는 이유
       - 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해
       - 전역 변수의 사용을 억제하기위해
       - 정보를 은닉하기 위해

7.  **이벤트 루프**

    1. 이벤트 루프에 대해 설명, 동시성 모델에 대해 설명  
       자바스크립트는 싱글 스레드 기반 언어.  
       함수를 실행하면 함수 호출이 스택에 순차적으로 쌓이고 스택의 맨 위에서 부터  
       아래로 한번에 하나의 함수만 처리할 수 있다.

       하지만, 자바스크립트에는 이벤트 루프라는 것을 통해 동시성을 지원한다.  
       (동시에 일어나는 것이 아니라 동시에 일어나는 것처럼 보이기 하는 것)

       이벤트 루프는 Call Stack에서 실행 중인게 있는지 확인하고, Task Queue에 작업이 있는지  
       확인해서 Call Stack이 비어있다면 Task Queue 내의 작업이 Call Stack으로 이동되어 실행

8.  **이벤트 버블링 & 캡쳐링** [참고 링크](https://velog.io/@soulee__/JavaScript-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%BA%A1%EC%B3%90-%EC%9C%84%EC%9E%84)

    1. `버블링`: 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가  
       타겟부터 최상위 요소까지 이벤트를 전파 시킴
    2. `캡쳐링`: 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가  
       최상위 요소부터 타겟까지 이벤트를 전파 시킴 (버블링과 반대)
    3. addEventListener의 기본 동작 방식은 _버블링_  
       변경하려면 3번째 매개변수(capture)를 true로 변경!
    4. 이벤트 전파를 막으려면?  
       `event.stopPropagation()`: 이벤트가 전파되는 것을 막는 API.

       이 기능을 사용하게 된다면?

       - 이벤트 버블링의 경우 클릭한 요소의 이벤트만 발생시키게 됨.
       - 이벤트 캡쳐링의 경우 클릭한 요소의 최상위 요소의 이벤트만 동작 시킴

9.  **이벤트 델리게이션 (이벤트 위임)**

    - 이벤트 위임이란 자식 엘리먼트의 이벤트를 부모엘리먼트에서 감지할 수 있으니  
      이벤트를 하나하나 등록하는 것이 아니라 부모에게 이벤트를 위임 하는 방법
    - 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식

10. **Promise**

    1.  `Promise`와 `Callback`의 차이점은 무엇이며 각각의 장단점에 대해 설명해달라  
        둘 다 자바스크립트에서 비동기처리를 위해서 사용되는 패턴이며,  
        Callback 같은 경우 함수의 처리 순서를 보장하기 위해서 함수를 중첩하게 사용되는 경우가  
        발생해 콜백지옥이 발생하는 단점과 에러처리가 힘들다라는 단점이 있다.  
        그래서 나온게 Promise이며 ES6부터 정식 채택되어 사용중이다.  
        Promise 생성자 함수를 통해 인스턴스화하며,

        예시 코드  
        ```jsx
        // Promise 객체의 생성
        const promise = new Promise((resolve, reject) => {
            // 비동기 작업을 수행한다.

            if (/* 비동기 작업 수행 성공 */) {
            resolve('result');
            }
            else { /* 비동기 작업 수행 실패 */
            reject('failure reason');
            }
        });
        ```

        비동기 처리에 성공하면 `resolve` 메서드를 호출해 비동기 처리 결과를 후속처리 메서드에 전달  
        비동기 처리에 실패하면 `reject` 메서드를 호출해 에러메세지를 후속처리 메서드로 전달

        후속처리 메서드는 then과 catch가 있다. 둘 다 Promise를 반환한다.  
        then을 가지고 메서드 체이닝을 통해 콜백지옥 문제를 해결 할 수 있다.

    2.  async ~ await  
        `Promise`를 더 쉽게 사용할 수 있도록 ES2017 (ES8)에서 추가된 문법  
        함수의 앞부분에 `async` 키워드를 추가하고, 함수 내부에서  
        Promise의 앞부분에 `await` 키워드를 사용한다.

        async ~ await를 사용할 경우 코드가 간결해지지만, 에러 처리를 잡기 위해 `try~catch`를 사용해야 한다.  
        동기적인 코드흐름으로 개발이 가능하다.

11. **프로토타입이란**?

    1.  자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거  
        (중복 제거 방법은 기존의 코드를 재사용하는 것!)

        즉, 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에  
        미리 구현해 놓음으로써 또 구현하는 것이 아니라 상위(부모) 객체인 프로토타입의 자산을 공유하여  
        사용할 수 있다

    2.  `__proto__` 접근자 프로퍼티로 자신의 프로토타입, 즉 Prototype 내부슬롯에 접근 할 수 있음.
    3.  프로토타입체인이란?  
        객체의 프로퍼티에 접근하려고 할 때 객체에 접근하려는 프로퍼티가 없으면,  
        `__proto__` 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모역할을 하는 프로토타입의  
        프로퍼티를 순차적으로 검색한다.

        프로토타입체인의 최상위 객체는 `Object.prototype` 이다.  
        이 객체의 프로퍼티와 메소드는 모든 객체에게 상속된다.

    4.  prototype 프로퍼티  
        생성자함수가 생성할 인스턴스의 프로토타입을 가르킨다.

12. **옵저버 패턴이란?**  
    어떤 객체의 상태가 변할 때 그와 연관된 객체 들에게 알림을 보내는 디자인 패턴 ([참고](https://pjh3749.tistory.com/266))

---

### 일반 질문들

1.  **SPA**란?  
    서버로부터 완전한 새로운 페이지를 불러오지 않고 현재의 페이지를 동적으로 다시 작성하는 함으로써  
    사용자와 소통하는 웹 애플리케이션이나 웹사이트를 말한다.

    1. 처음 렌더링이 늦은 단점이 있지만 화면에 필요한 부분만 렌더링 되기에 화면 이동이 빠릅니다.

2.  **자바스크립트 원시값?**  
    Number, BigInt, String, Boolean, Symbol, undefined, null (_주의, Object는 원시값 아님!!_)

    - undefined는 선언만 되어있고 정의가 되어있지 않은 상태
    - null은 자료형이며 객체, 빈값을 의미

3.  **가비지컬렉션 알고리즘**  
    메모리 할당을 추적하고 할당된 메모리 영역이 필요하지 않은 영역일 경우를 판단해서 회수하는 것.

    자바스크립트에서 변수는 직접적으로 참조 값(문자열, 객체, 배열 등)을 담고 있지 않고,  
    해당 값을 메모리 상에 저장 된다.

    그래서 참조 값을 생성하고나서 더이상 참조할 것이 없거나 비어졌을 때 가비지 컬렉터가 동작해서  
    메모리가 반환됨. (메모리를 다시 재사용할 수 있는 상태가 된다)

4.  **Webpack이란?**  
    webpack은 모듈 번들러로 파일 확장자에 맞는 로더에게 위임해서 하나로 묶어준다.  
    (최종 배포용 파일을 만들어줌)

    `<script>` 태그가 여러개 있을 때 순서보장도 중요하기에 이런것도 webpack에서 처리해줌.

5.  **OOP의 특징에 대해 설명**
    - 상속
      클래스개념에서 상위 클래스(부모)로 부터 하위 클래스(자식)이 유산을 물려받는것과 같이,  
      부모의 메소드나 변수를 사용할 수 있는 것을 말함
    - 다형성
      같은 함수가 있다고 칠대 그 함수가 매개변수에 따라 다른 역할을 할 수 도 있다.
    - 캡슐화
      보통 데이터를 은닉시킨다고 표현하는데, 외부에서 쉽게 데이터를 접근할 수 없게  
      만들기도하고, 데이터 구조와 데이터를 다루는 방법들을 한데다 묶는 것
    - 추상화
      공통적인 속성이나 기능을 묶어서 이름을 붙이는 것

6.  **함수형 프로그래밍**

    1.  함수형 프로그래밍이란?
        함수형 프로그래밍은 순수함수와 보조 함수의 조합을 통해  
        로직내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고  
        변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.
    2.  순수 함수란?
        - 순수함수는 같은 입력이 주어지면, 같은 출력을 반환해야하고,  
          side effect(부작용) 이 없어야한다.
        - 함수형 프로그래밍은 순수함수를 통해 side effect를 최대한 억제하여  
          오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법
    3.  OOP와 함수형 프로그래밍의 가장 큰 차이점은 무엇?  
        객체지향은 객체 안에 상태를 저장하고,  
        이 상태를 이용해서 메소드를 추가하고 상태변화를 설정하고 조정하기위해 다양한 기능을 사용한다.  
        이에 반해 함수형 프로그래밍은 상태를 제어하는것보다 상태를 저장하지 않고 없애는데 주력한다.

        예를 들면, 객체 지향은 상태를 저장하는 필드와 그 필드들을 이용해  
        기능을 제공하는 메소드를 만들고 클래스를 만듭니다.  
        반면 함수형은 몇몇 자료구조(list, map, set) 등을 이용해 최적화된 동작을 만들어낸다  

    4.  고차 함수란?
        - 고차 함수는 함수를 인자로 받거나 함수를 리턴하는 함수를 말한다.  
          이 때 다른 함수의 인자로 전달되는 함수를 콜백 함수라고 한다.

---

### 인성 관련 (?)

1. 팀 프로젝트 시 마찰이 있었을 때 극복한 방법

### 의견이나 중요할 것 같은 것들

1. 과제에 대해서 물어볼 것 같음

---

**참고링크**

- [프론트엔드 개발자 면접 질문(기술면접) 정리](https://sunnykim91.tistory.com/121)
- [프론트엔드 개발자 기술면접 인터뷰 질문 모음](https://realmojo.tistory.com/300)
