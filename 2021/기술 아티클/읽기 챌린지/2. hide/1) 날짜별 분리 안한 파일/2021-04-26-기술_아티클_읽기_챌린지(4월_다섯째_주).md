---
title: '기술 아티클 읽기 챌린지 (4월 다섯째 주)'
categories: [Tech, Challenge]
date: 2021-04-26 21:16:00 +0900
tags: [공부, 기술문서]
comments: true
---

# 기술 아티클 읽기 챌린지 (4월 다섯째 주)

## 매일 매일 한 개의 기술 문서 읽기!!

**_시작날짜: 2021.04.07_**

### **> 2021년 4월 26일** (자바스크립트는 무엇으로 구성되어있을까?)

**_일부만 작성_**

**값 (Value)**

-   **null 과 undefined**  
    일반적으로 `null`은 의도적으로 값이 없는 것을 의미하며,  
    `undefined`는 의도하지 않게 값이 없는 것을 의미함.

**객체**

-   **객체 항등(Identity)**  
    2는 2와 같다(다시 말하면, 2 === 2)라 했다  
    왜냐하면 2를 작성하는 어디에서나 항상 같은 값이 "소환"되기 때문
    -   하지만 `{}`를 작성한다면, 항상 다른 값이 될 것  
         콘솔 창에 `{} === {}`를 실행하면 항상 false 반환
        -   컴퓨터가 코드에서 2를 만나면 항상 같은 2를 반환할 것  
             하지만 객체 리터럴은 다름. 컴퓨터가 `{}`를 만나면 항상 새로운 객체를 생성함!
    -   객체 항등(identity)은 무엇일까?  
         그것은 여전히 동일하거나, 값의 동일성을 나타내는 또 다른 용어
        -   "a와 b가 항등이다"라고 말하는 것은 "a와 b가 같은 값을 가리키고 있다"는 것을 의미  
             `a === b`
        -   "a와 b가 항등이 아니다"는 것은 "a와 b가 다른 값을 가리킨다"는 것을 의미  
             `a !== b`

**함수**

-   **매개 변수**  
    `sayHi("Amelie")`처럼 매개변수를 이용하면 함수로 몇 가지 정보를 전달할 수 있다.  
     함수 내에서 매개변수는 변수처럼 동작한다.

    -   이 값들은 "인자" 혹은 "매개변수"로 불린다  
        (함수를 정의하는 부분인지 호출하는 부분인지에 따라서..)  
        그러나 엄격하게 구분할 필요는 없고, 두 용어는 같이 사용될 수 있다.

-   **this**  
    `this`는 아마 자바스크립트 개념 중 가장 오해받고 있는 함수의 특별한 인수  
     함수를 사용할 때 직접 `this`를 넘기지 않음  
     대신, 함수 호출 방식에 따라 자바스크립트 자체가 `this`를 넘겨줄 것이다.

    -   예를 들어, 점 표기법 .을 사용하여 호출할 경우(`iceCream.eat()` 처럼)  
         this는 .앞에 있는 값일 것. (예시에서는 `iceCream`)
    -   `this`는 함수가 어디서 정의되었는지가 아니라, 어디서 호출되었는지에 따라 달라진다.
    -   `.bind`, `.call`, `.apply` 같은 헬퍼를 이용하면 `this`를 좀 더 효과적으로 제어할 수 있을 것.

-   **화살표 함수**  
     (일부 작성)

    -   화살표 함수는 this의 개념이 없음
    -   만약 화살표 함수에서 this를 사용한다면, 가장 가까운 "일반" 함수의 this를 사용함
        -   매개변수나 함수에 존재하는 변수만 사용하는 것과 비슷.
        -   사람들이 화살표 함수를 사용하는 것은 코드상에서 둘러싸고 있는 것을  
             그대로 "보고" 싶을 때 사용한다는 것을 의미

-   **콜 스택**  
    함수를 호출하는 것은 방에 들어가는 것과 같음.  
     함수를 호출할 때마다, 함수 내부에 있는 변수들을 매번 초기화 함.

    -   함수를 호출하는 것은 코드를 사용해 새로운 "방"을 구성하고 들어가는 것과 같음  
         함수의 변수들은 방에 "살아 있게" 됨.  
         함수가 종료되면, "방"과 모든 변수는 사라진다.
        -   사용자는 이런 방을 수직 스택으로 시각화 할 수 있을 것임.  
             이것이 콜 스택이다.  
             함수가 종료되면, 콜 스택의 "아래" 함수로 돌아가게 된다.

-   **고차함수(Higher-Order Function)**  
    고차 함수는 다른 함수를 인수로 사용하거나 그것을 반환하여 처리하는 함수

-   **클로저**  
     일반적으로, 함수가 종료되면 모든 변수는 "사라진다".  
     왜냐하면 더는 선언된 변수가 필요가 없어지기 때문.  
     그러나 함수 내부에 함수를 선언한다면 어떻게 될까?
    -   내부에 있는 함수는 이후에 여전히 호출될 수 있고, 외부함수의 변수에 접근할 수 있게 된다.  
         실제로 클로저는 매우 유용하다!
    -   클로저가 동작하기 위해서는, 외부 함수의 변수는 어딘가 "그대로 놓여" 있어야 함.  
         따라서 이때는, 자바스크립트는 변수를 "잊어버리지" 않고 "변수를 살려둔 채"로 유지하게 됨.  
         이것을 "클로저"라 부른다.  
         클로저는 종종 오해의 소지가 있는 자바스크립트의 기능으로 간주하지만,  
         사용자는 아마 그것을 깨닫지 못한 채 자주 사용할 것임

**참고 링크**

-   [자바스크립트는 무엇으로 구성되어있을까?](https://ui.toast.com/weekly-pick/ko_20200219)

---

### **> 2021년 4월 27일** (그래프)

**_다익스트라는 잘모르겠다... 나중에 다시 읽어보자. 그 전에 BFS DFS 확실히 이해 좀!_**

**깊이 우선탐색 & 너비 우선 탐색**  
<img src="https://user-images.githubusercontent.com/33610315/116250074-61acf000-a7a8-11eb-8b9c-ff1a0a0616ad.gif" width="400" />

-   깊이 우선 탐색 (**DFS**; Depth First Search)  
     시작 정점에서 한 방향으로 갈 수 있는 가장 먼 경로까지 탐색하다가 갈 곳이 없으면,  
     가장 마지막에 만났던 부모 노드로 돌아와서 다른 방향을 탐색하는 방법
-   너비 우선 탐색 (**BFS**; Breadth First Search)  
     시작 정점에서 인접한 모든 정점들을 우선 방문한 후, 더 이상 방문하지 않은 정점이 없을 때까지  
     방문했던 정점들을 다시 시작점으로 해서 모든 정점들을 차례로 방문하는 방법

**다익스트라 알고리즘**  
<img src="https://user-images.githubusercontent.com/33610315/116251789-f6641d80-a7a9-11eb-8d33-8e1baf3b17e4.png" width="300" />

-   너비 우선 탐색(이하 BFS)가 최단 경로를 구하는 알고리즘이라면,  
     다익스트라 알고리즘은 **가장 빠른 경로를 구하는 알고리즘**

-   **다익스트라 알고리즘의 단계**
    1.  가장 가격이 싼 정점을 찾는다. 가장 가격이 싼 정점이란 도달하는 데 시간이 가장적게 걸리는 정점을 말한다.
    2.  이 정점의 이웃 정점들의 가격을 조사한다.
    3.  그래프 상의 모든 정점에 대해 이러한 일을 반복한다.
    4.  최종 경로를 계산한다.

**참고 링크**

-   [그래프](https://seonghui.github.io/TIL/docs/algorithm/graph/graph.html)
-   [그래프 - 너비 우선 탐색(BFS)](https://seonghui.github.io/TIL/docs/algorithm/graph/bfs.html)
-   [그래프 - 깊이 우선 탐색(DFS)](https://seonghui.github.io/TIL/docs/algorithm/graph/dfs.html)
-   [그래프 - 다익스트라 알고리즘](https://seonghui.github.io/TIL/docs/algorithm/graph/dijkstra.html)

---

### **> 2021년 4월 28일** (잘 가, 클린 코드)

**누가봐도 클린 코드인데? (물론 내가 봤을 때..?)**

-   이 글을 읽으면서 초반부에 예시를 들어 코드를 리팩토링하고 더 깔끔하게 만들었는데,  
     팀 리더와 다른 사람들의 반응이 좋지 않았다고 한다.  
     나도 읽으면서 글쓴가 생각했던 것처럼 글쓴이가 새로 짠 코드가 훨씬 깔끔하다고 느꼈었다.
-   반전은 그들이 옳았다는 것을 깨닫는 데는 몇 년이 걸렸다한다..

**하나의 단계일 뿐이다**

-   많은 사람들이 “클린 코드”나 중복 제거에 얽매이는 시기를 겪는다.  
     이 시기에는 본인이 짠 코드에 자신이 없을 경우,  
     측정할 수 있는 무언가를 통해 자신감이나 만족감을 얻고 싶은 욕구를 느끼게 된다.
    대표적으로 엄격한 lint 규칙, naming 규칙, 폴더 구조, 중복 제거 등이 그렇다.

    -   **나도 약간 그런 것 같다...**

-   중복 제거를 자동화할 수는 없지만 연습을 통해 능력을 개선시킬 수는 있음.

    -   중복을 제거한 것은 코드에 대한 객관적인 지표를 개선시킨 것처럼 느끼게 만든다.
    -   더 심한 경우엔, <span style="color: gray">“난 코드를 깔끔하게 짜는 훌륭한 개발자야!”</span> 라는 결론에 이르게 될 수도 있다.
    -   이는 **자기기만** 만큼이나 **안 좋은 결과**를 가져다 줄 수 있음!!

-   글 초반의 리팩토링은 두가지 재앙이었다.
    -   **1)** 코드를 작성한 사람과 변경에 대해 논의하지 않았던 것
        -   협업에서 이런식으로 업무를 처리하는 것은 최악.
        -   훌륭한 엔지니어링 팀은 끊임없이 신뢰를 만들어 나감.  
             별다른 상의 없이 동료의 코드를 변경하는 것은 언젠가 후폭풍을 불러 올 것!!
    -   **2)** 완벽한 개선이란 없다는 것

**정리**

-   코딩은 하나의 여정이다.
-   함수나 클래스를 통해 로직을 분리시켜 코드를 심플하게 만드는 것은 처음엔 정말 즐거운 일이었을 것.  
     자신의 코드가 깔끔하고 멋져보이는 순간, 그 깔끔함에 매료됐을 것이며, 한동안은 계속 그렇게 해도 됨.
    > **하지만!!!** 여기서 멈춰 클린코드충이 되지는 말자.  
    > 클린 코드는 목표가 아님 (단지 프로그램의 복잡성을 줄이고자 하는 시도일 뿐)  
    > 코드가 어떻게 바뀔지 모르는 상황에서, 피해를 최소한으로 줄이고자 하는 방어 전략 중 하나일뿐이니까.

**참고 링크**

-   [Overreacted : 잘가, 클린 코드](https://overreacted.io/ko/goodbye-clean-code/)

---

### **> 2021년 4월 29일** (애자일 방법론)

**애자일이 중요시 여기는 것**

-   팀원 간 협력
    -   아무리 자신이 빨리하고 잘하더라도, 팀원이 봤을 때 코드가 어색하고  
         읽기 힘들다면 팀원들은 나와 같이 일하기 싫어진다.
-   피드백
    -   일정에 쫓겨 개발만 하다보면 내 코드를 점검할 시간이 줄어들게 됨  
         다른 사람들에게 내 코드를 보여주고 피드백을 받으면서 서로 같이 성장할 수 있게 됨!
-   애자일은 불확실한 상황에서 빛을 발함.
    -   애자일이 추구하는 가치는 **처음부터 완벽한 계획**이 아닌 **간소한 계획과 유연한 대처**
    -   폭포수 모델과 애자일 모델 비교  
        <img src="https://user-images.githubusercontent.com/33610315/116555863-d06c8380-a937-11eb-8223-8c083039f9a2.png" width="500">
        -   각 단계가 순차적으로 실행되고 다시 돌아갈 수 없는 폭포수 모델은  
            소프트웨어보다는 제조업에 더 적합한 방법론
        -   소프트웨어는 변화가 매우 많기 때문에 짧은 주기의  
            개발 단위를 여러번 반복하는 애자일 방법론이 더 적합하다는 의견이 많음

**애자일의 장점**

-   **1.** 점진적으로 테스트 할 수 있어서 버그를 더 빠르게 발견 할 수 있습니다.
-   **2.** 수정과 변경에 유연합니다.
-   **3.** 프로젝트를 시작할때 계획에 버리는 시간을 줄일 수 있습니다.
-   **4.** 서비스가 더 빨리 출시됩니다.

**애자일에서의 스프린트(Sprint)란?**

-   워터폴에서는 프로젝트 진행에서 데드라인을 제일 중요시 여기지만,  
     애자일에서는 애자일속도(프로젝트 진행 속도)를 제일 중요시 여김!

**애자일에서의 일의 단위**

-   Theme > Epic > Story(기본단위) > Task(티켓 할당 단위)
-   예시
    -   **1.** Theme: 종합 온라인 쇼핑몰 구축
    -   **2.** Epic: 고객은 스마트폰이나 데스크탑으로 주문을 할 수 있다.
    -   **3.** Story: 고객(누가)은 주문을 하기 위해서(왜) 배송 시간을 고를 수 있어야 한다.(행동)
    -   **4.** Task: 배송 시간을 선택할 수 있는 기능을 구현한다.

**느낀 점**

-   애자일은 일정을 맞추기 위해 야근을 불사하는 것이 아니라 한다.  
    역시 폭포수모델은 소프트웨어 개발자에겐 좋지 않은 방법같다.
-   스크럼 부분이라던가.. 그 아래부분 다시 읽어보자!

**참고 링크**

-   [애자일 방법론](https://simsimjae.medium.com/애자일-방법론-753368aa3058)
